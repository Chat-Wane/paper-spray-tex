
\section{\SCAMPLON{}}
\label{sec:proposal}

\SCAMPLON{}\footnote{\SCAMPLON{} stands as the contraction of \SCAMP{} and
  \CYCLON{}.} is a random peer sampling protocol inspired by both \SCAMP{} and
\CYCLON{}. It provides the best of its parents: a logarithmically increasing
partial view size compared to the global network size, and fast convergence to
a random graph using only neighbour-to-neighbour connection establishments. As
such, it constitutes an improvement over state-of-the-art approaches in the
common context of one-way connections. Additionally, it greatly outperforms
state-of-the-art in the three-way handshake connection establishments. The
latter context becomes increasingly important with the apparition of technology
allowing peer-to-peer within modern web browsers. This section details the
\SCAMPLON{} protocol through intuitions, examples and algorithms.

\begin{asparadesc}
\item [Scamplon] reuses the joining process of \SCAMP{} to incrementally build
  the network. While such network is not flawless, it has the interesting
  property of logarithmically increasing the number of connections at each
  join, compared to the global network size. Still, newest members have a small
  partial view size, and oldest peers are more clustered. To alleviates these
  issues, a periodic \CYCLON{}-like protocol takes place in order to balance
  the partial views, using only neighbour-to-neighbour interactions. This
  balancing concerns both the partial view sizes, and the uniformity of chosen
  peers within them. Unfortunately, \CYCLON{} handles fixed-size partial
  views. Therefore, it must be adapted to handle partial views that grow and
  shrink as the network dynamically adapts to the membership.
\end{asparadesc}

The first issue of \CYCLON{} concerns the partial view sizes. For the recall,
the user of \CYCLON{} must foresee the maximum size of the network to set the
partial view size, and the size of the subset to exchange from
neighbour-to-neighbour.  However, in \SCAMPLON{}, a peer with $2$ neighbours in
its partial view can exchange with a peer with $10$ neighbours. Ideally, the
resulting size of both partial views would be $6$ after the exchange. Yet,
reaching this ideal value in one cycle is difficult without the knowledge of
each other's partial view size. Instead of acquiring this knowledge,
\SCAMPLON{} aims to converge to the ideal value by averaging their view size
over exchanges. Therefore, the initiating peer sends
$\left\lceil\mathcal{P}\over{2}\right\rceil$ members to the chosen peer (chosen
by age). The latter sends back $\left\lceil\mathcal{P}\over{2}\right\rceil$
members too. After the receipt, both peers remove the sent members and add the
received members. It worth noting that the global number of connections after
the process must not change. Otherwise, \SCAMPLON{} cannot guarantee that the
partial view sizes are logarithmic in average compared to the network size.

A remarkable difference regarding \CYCLON{} is that \SCAMPLON{} explicitly
allows to have a same neighbour multiple times in a partial view. It impacts on
the clustering coefficient. However, the impact is not significant since these
artefacts are not numerous because the graph is random, and because they
disappear over the \SCAMPLON{} cycles (EXAMPLIFY).

There are few optimisations concerning the establishments of connections. For
instance, when a peer $p$ starts an exchange with $q$, and $q$ has $p$ in its
partial view, instead of inverting the link between $p$ and $q$, and $q$ and
$p$, \SCAMPLON{} does not change them. Another optimisation concerns a peer
having a neighbour multiple times in its partial view. While \SCAMPLON{} keeps
such information in its partial view, only one connection per neighbour is
necessary.

\begin{asparadesc}
\item [Algorithm]\ref{algo:scamplon} shows the \SCAMPLON{} protocol running at
  each peer. It is divided between an active thread looping to update the
  partial view, and the passive thread which provides the reactions to received
  messages. The functions which are not explicitely defined are the following:
  \begin{itemize}
  \item $incrementAge(view)$: increments the age of each elements in the view
    and returns the modified view.
  \item $getOldest(view)$: retrieves the oldest of peers contained in the view
  \item $getSample(view, \, size)$: returns a sample of the view containing
    $size$ elements.
  \item $replace(view,\,old,\,new)$: replaces in the view all occurances of the
    $old$ element by the $new$ element and returns the modified view.
  \item $rand()$: generates a random number between 0 and 1.
  \end{itemize}
  A peer $o$ joining the network will reach a contact peer. The latter will
  call Function $onContact$ which spreads $(|\mathcal{P}|+c)$ copies of $o$
  inside the network. Then, each time a peer receives one of these message,
  assuming that this peer does not have $o$ already and this peer is not $o$,
  it has a probability $1\over{|\mathcal{P}|+1}$ to integrate $o$ in
  $\mathcal{P}$. Otherwise it forwards the copy to a random neighbour.  At this
  point, $o$ has $1$ neighbour in its partial view, and appears $(c+1)log(N)$
  times in partial views of other members. The active thread aims to balance
  the partial views. Each time Function $loop$ is called, the age of each
  element in $\mathcal{P}$ is incremented. Then, the oldest peer $q$ is chosen
  to exchange a subset of their partial view. If Peer $q$ cannot be reached
  (i.e. it crashed/disconnected), it is removed from the partial view and the
  operation is repeated. Once the initiating peer $p$ found a reachable peer
  $q$, the former selects a sample of its partial view, excluding $q$ and
  including itself. The size of this sample is half of its partial view, with a
  minimum of one peer: the initiating peer. The answer of $q$ is of the exact
  same kind. Since peers can appear mutliple times in $\mathcal{P}$, the
  exchanging peers may send references to the other peer, e.g., Peer $o$'s
  sample can contain references to $q$. Such sample, without further
  processing, would create self-loop ($q$'s partial view contains references to
  $q$). To alleviate this indesirable behaviour, all occurrences of the other
  peer are replaced with the emitting peer.  Afterwards, both of them remove
  the sent sample from their view, remove the chosen neighbour, and add the
  received sample.
\end{asparadesc}

Note that extending the algorithm to provide handshaking is not difficult: it
only requires to keep track of the neighbour from where the membership messages
arrived, and forward the answer to this neighbour accordingly.

\begin{algorithm}
  \input{./input/scamplonalgo.tex}
  \caption{\label{algo:scamplon}The \SCAMPLON{} protocol.}
\end{algorithm}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
