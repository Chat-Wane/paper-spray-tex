
\section{\SCAMPLON{}}
\label{sec:proposal}

\SCAMPLON{}\footnote{\SCAMPLON{} stands as the contraction of \SCAMP{} and
  \CYCLON{}.} is a random peer sampling protocol inspired by both \SCAMP{} and
\CYCLON{}.  Firstly, \SCAMPLON{} reuses the joining process of \SCAMP{} to
incrementally build the network. While such network is not flawless, it has the
interesting property of logarithmically increasing the number of connections at
each join, compared to the global network size. Still, the newest members have
a small partial view size, and the oldest peers are more clustered. To
alleviates these issues, a periodic \CYCLON{}-like protocol takes place in
order to balance the partial views, using only neighbor-to-neighbor
interactions. This balancing concerns both the partial view sizes, and the
uniformity of chosen peers within them.

\SCAMPLON{} is adaptive, e.g., a peer with $2$ neighbors in its partial view
can exchange with a peer with $10$ neighbors. Ideally, the resulting size of
both partial views would be $6$ after the exchange. Yet, reaching this ideal
value in one cycle is difficult without the knowledge of each other's partial
view size. Instead of acquiring this knowledge, \SCAMPLON{} aims to converge to
the ideal value by averaging their view size over exchanges. Therefore, the
initiating peer $p_1$ sends $\left\lceil|\mathcal{P}_1|\over{2}\right\rceil$
members to the chosen peer $p_2$ (chosen by age). The latter sends back
$\left\lceil|\mathcal{P}_2|\over{2}\right\rceil$ members too. After the
receipt, both peers remove the sent members and add the received members. It
worth noting that \SCAMPLON{} uses a multiset as partial view. Therefore, a
neighbor can appear multiple times in a partial view, nonetheless, it
guarantees that the global number of connections after the process does not
change. The latter is crucial to ensure that each partial view tends to the
desired logarithmic size.

There exists a close relationship between \SCAMPLON{} and the proactive
aggregation protocol introduced
in~\cite{jelasity2004epidemic,montresor2004robust}. The latter states that,
under the assumption of a peer sampling sufficiently random, the mean value
$\mu$ and the variance $\sigma^2$ at a given cycle $i$ are:
\begin{center}
  $\mu_i = {1\over{|\mathcal{N}|}} \sum\limits_{x \in \mathcal{N}} a_{i,\,x}$
  \hfill
  $\sigma^2_i = {1\over{|\mathcal{N}|-1}}\sum\limits_{x \in \mathcal{N}}
  (a_{i,\,x} - \mu_i)^2$
\end{center}
where $a_{i,\,x}$ is the value held by Peer $p_x$ at cycle $i$. The estimated
variance must converge to $0$ over cycles. In other terms, the values tends to
be the same over cycles. In the \SCAMPLON{} case, the value $a_{i,\,x}$ is the
partial view size of Peer $p_x$ at cycle $i$. Indeed, each exchange from Peer
$p_1$ to Peer $p_2$ is an aggregation resulting to:
$|\mathcal{P}_1|\approx|\mathcal{P}_2|\approx{|\mathcal{P}_1| + |\mathcal{P}_2|
  \over{2}}$.
Furthermore, each peer performs this exchange protocol $1+Poisson(1)$ times per
cycle, i.e., they initiate one and receive one in average.  This relation being
established, we know that \SCAMPLON{} converges exponentially fast. More
precisely, each cycle decreases the variance estimation of the overall system
by ${2\sqrt{\text{e}}}$.

\begin{asparadesc}
\item [Algorithm]\ref{algo:scamplon} shows the \SCAMPLON{} protocol running at
  each peer. It is divided between an active thread looping to update the
  partial view, and the passive thread which provides the reactions to received
  messages. The functions which are not explicitly defined are the following:
  \begin{itemize}
  \item $incrementAge(view)$: increments the age of each elements in the view
    and returns the modified view.
  \item $getOldest(view)$: retrieves the oldest of peers contained in the view
  \item $getSample(view, \, size)$: returns a sample of the view containing
    $size$ elements.
  \item $replace(view,\,old,\,new)$: replaces in the view all occurrences of
    the $old$ element by the $new$ element and returns the modified view.
  \item $rand()$: generates a random number between 0 and 1.
  \end{itemize}
  A peer $o$ joining the network will reach a contact peer. The latter will
  call Function $onContact$ which spreads $(|\mathcal{P}|+c)$ copies of $o$
  inside the network, $c$ being a small constant value (typically lower that
  $3$). Then, each time a peer receives one of these message, assuming that
  this peer is not $o$, it has a probability $1\over{|\mathcal{P}|+1}$ to
  integrate $o$ in $\mathcal{P}$. Otherwise it forwards the copy to a random
  neighbor.  At this point, $o$ has $1$ neighbor in its partial view, and
  appears $(c+1)log(|\mathcal{N}|)$ times in partial views of other
  members. The active thread aims to balance the partial views. Each time
  Function $loop$ is called, the age of each element in $\mathcal{P}$ is
  incremented. Then, the oldest peer $q$ is chosen to exchange a subset of
  their partial view. If Peer $q$ cannot be reached (i.e. it crashed/left), it
  is removed from the partial view and the operation is repeated. Once the
  initiating peer $p$ found a reachable peer $q$, the former selects a sample
  of its partial view, excluding $q$ and including itself. The size of this
  sample is half of its partial view, with a minimum of one peer: the
  initiating peer. The answer of $q$ is of the exact same kind. Since peers can
  appear multiple times in $\mathcal{P}$, the exchanging peers may send
  references to the other peer, e.g., Peer $o$'s sample can contain references
  to $q$. Such sample, without further processing, would create self-loop
  ($q$'s partial view contains references to $q$). To alleviate this
  undesirable behavior, all occurrences of the other peer are replaced with the
  emitting peer.  Afterwards, both of them remove the sent sample from their
  view, remove the chosen neighbor, and add the received sample.
\end{asparadesc}


\begin{algorithm}
  \input{./input/scamplonalgo.tex}
  \caption{\label{algo:scamplon}The \SCAMPLON{} protocol.}
\end{algorithm}

Note that extending the algorithm to provide handshaking is not difficult: it
only requires to keep track of the neighbor from where the membership messages
arrived, and forward the answer to this neighbor accordingly. Also, there are
few optimization concerning the establishments of connections. For instance,
when a peer $p$ starts an exchange with $q$, and $q$ has $p$ in its partial
view, instead of inverting the link between $p$ and $q$, and $q$ and $p$,
\SCAMPLON{} does not change them. Another optimization concerns a peer having a
neighbor multiple times in its partial view. While \SCAMPLON{} keeps such
information in its partial view, only one connection per neighbor is truly
necessary.

\begin{figure*}
  \centering
  \input{input/scamplonexample.tex}
  \caption{\label{fig:scamplonexample}Example}
\end{figure*}

To summarize, \SCAMPLON{} provides the best of its parents:
\begin{inparaenum}[(i)]
\item a logarithmically increasing partial view size compared to the global
  network size,
\item a constant complexity to establish the connections,
\item an exponentially fast convergence to a random graph.
\end{inparaenum}
Providing these three properties, \SCAMPLON{} improves the state-of-the-art
approaches~\cite{ganesh2001scamp,voulgaris2005cyclon} in the traditional
connection set-up. Furthermore, the improvement becomes crucial in the context
of three-way handshake connection set-up.  The latter becomes increasingly
important with the appearance of technologies allowing peer-to-peer within
modern web browsers.  The next section aims to demonstrate experimentally the
behavior of \SCAMPLON{}. In particular, it aims to highlight the
aforementioned properties.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
