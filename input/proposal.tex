
\section{\SCAMPLON{}}
\label{sec:proposal}

\SCAMPLON{}\footnote{\SCAMPLONDESCRIPTION{}} is scalable and adaptive random
peer sampling protocol inspired by both \SCAMP{} and \CYCLON{}. \SCAMPLON{}
comprises three parts representing the lifecycle of a peer in the network.
Firstly, \SCAMPLON{}'s joining process incrementally builds the network by
injecting in it a logarithmically growing number of connections. However, the
resulting network is far from flawless. Consequently, each peer runs a periodic
process in order to balance the partial views both in terms of partial view
size, and uniformity of the chosen peers within them. Quickly, the network
topology converges to a random graph. Finally, A peer is able to leave at any
time without giving notice, still the network properties do not degrade. During
the whole lifecycle, a peer uses local knowledge only and establishes
connections only with the neighbors of its neighbors.

\subsection{Joining}

The main focus of the joining protocol is about establishing a logarithmically
growing number of connections in the network compared to the number of members.
\SCAMPLON{} assumes that each peer has a logarithmic partial view size. Thus,
when a peer $p_1$ contacts a peer $p_2$ within the network, Peer $p_2$ is able
to use its partial view size to spread the appropriate number of subscriptions.
\SCAMPLON{} cautiously establishes connections with the neighbors of
neighbors. Therefore, the joining protocol at Peer $p_2$ simply forwards the
identity of $p_1$ to the latter's neighbors where they add it to their partial
view. Afterwards, $p_1$ is connected to $p_2$, and all the neighbors of $p_2$
are connected to $p_1$. The total number of connections in the network gently
increases of $1+\ln(|\mathcal{N}|)$.

Algorithm~\ref{algo:joiningalgo} shows the simplicity of this joining
protocol. First, the partial view $\mathcal{P}$ is a multiset of pairs
$\langle n,\, age\rangle$ which associate to the neighbor $n$ the age $age$
(the age is useful in the periodic protocol). Thus, a neighbor can appear
multiple times in the partial view. Second, the algorithm shows the $onSubs$
event called each time a peer joins the network which simply forwards the
identity of the joining peer to all neighbors, indifferently of the age. The
$onFwdSubs$ event is called when a peer receives such forwarded
subscription. It adds the peer as one of its neighbor with an age set to $0$
meaning that it is a brand new connection.

\begin{figure}
  \centering
  \input{./input/joiningexample.tex}
  \caption{\label{fig:joiningexample}Example of the \SCAMPLON{}'s joining
    protocol. In this scenario, Peer $p_1$ contacts $p_2$ to join the network
    composed of $\{p_2,\,p_3,\,p_4,\,p_5,\,p_6\}$ (for simplicity sake, only
    the new connections and the neighborhood of $p_1$ and $p_2$ are
    displayed). Peer $p_1$ directly adds $p_2$ in its partial view. Peer $p_2$
    forwards the identity of $p_1$ to its neighborhood. Each of these
    neighbors adds $p_1$ in their partial view. Five connections have been
    established.}
\end{figure}

\begin{algorithm}
\input{input/joiningalgo.tex}
\caption{\label{algo:joiningalgo}The joining protocol of \SCAMPLON{}.}
\end{algorithm}

Figure~\ref{fig:joiningexample} depicts a joining scenario. Although the
joining peer is connected to the network, the example shows that the network
topology is not ideal after a joining protocol. Indeed, the joining peer only
has one neighbor in its partial view, and all the neighbors of this neighbor
have the joining peer in their partial view. Consequently, the network is not
robust and highly clustered. Churn puts the connectedness at risk. To avoid it,
\SCAMPLON{} needs a balancing protocol.

\subsection{Cyclic}

\SCAMPLON{} is a random peer sampling protocol. As such, it must constantly
renew the connections to handle the churn (when peers join and leave freely).
To ensure this constant shuffling, \SCAMPLON{} repeats an exchanging procedure
during which two peers swap their neighbors. The swapping aims to balance both
the size of partial views and the global distribution of peers among them.

\SCAMPLON{} uses a multiset as partial view without any predefined boundary on
its size. Thus, two peers with different partial view sizes can swap their
neighbors, the objective being that both peers become as connected as one
another. The global number of connections and the connectedness must remain
unchanged.

\SCAMPLON{} converges to the ideal partial view size by averaging their size
over exchanges. Therefore, both peers involved send and integrate
$\left\lceil|\mathcal{P}|\over{2}\right\rceil$ neighbors from each
other. Since the partial views are multisets, even if a neighbor appears
multiple times, the network does not lose any connection. It guarantees that
the global number of connections after the protocol does not change.

There exists a close relationship between \SCAMPLON{} and the proactive
aggregation protocol introduced
in~\cite{jelasity2004epidemic,montresor2004robust}. The latter states that,
under the assumption of a peer sampling sufficiently random, the mean value
$\mu$ and the variance $\sigma^2$ at a given cycle $i$ are:
\begin{center}
  $\mu_i = {1\over{|\mathcal{N}|}} \sum\limits_{x \in \mathcal{N}} a_{i,\,x}$
  \hfill
  $\sigma^2_i = {1\over{|\mathcal{N}|-1}}\sum\limits_{x \in \mathcal{N}}
  (a_{i,\,x} - \mu_i)^2$
\end{center}
where $a_{i,\,x}$ is the value held by Peer $p_x$ at cycle $i$. The estimated
variance must converge to $0$ over cycles. In other terms, the values tends to
be the same over cycles. In the \SCAMPLON{} case, the value $a_{i,\,x}$ is the
partial view size of Peer $p_x$ at cycle $i$. Indeed, each exchange from Peer
$p_1$ to Peer $p_2$ is an aggregation resulting to:
$|\mathcal{P}_1|\approx|\mathcal{P}_2|\approx{|\mathcal{P}_1| + |\mathcal{P}_2|
  \over{2}}$.
Furthermore, at each cycle, each peer is involved in the exchange protocol at
least once (they initiate one), and in the best case 1+Poisson(1) (they
initiate one and, in average, each peer receives another one). This
relation being established, we know that \SCAMPLON{} converges exponentially
fast. Furthermore, we know that each cycle decreases the variance of the
overall system at a rate comprised between ${1\over{2}}$ and
$1\over{2\sqrt{\text{e}}}$.

\begin{algorithm}
  \input{./input/cyclicalgo.tex}
  \caption{\label{algo:scamplon}The cyclic protocol of \SCAMPLON{}.}
\end{algorithm}

Algorithm~\ref{algo:scamplon} shows the \SCAMPLON{} protocol running at each
peer. It is divided between an active thread looping to update the partial
view, and a passive thread which reacts to an exchange message. The functions
which are not explicitly defined are the following:
\begin{itemize}
\item $incrementAge(view)$: increments the age of each elements in the view
  and returns the modified view.
\item $getOldest(view)$: retrieves the oldest of peers contained in the view.
\item $getSample(view, \, size)$: returns a sample of the view containing
  $size$ elements.
\item $replace(view,\,old,\,new)$: replaces in the view all occurrences of
  the $old$ element by the $new$ element and returns the modified view.
\item $rand()$: generates a random floating number between $0$ and $1$.
\end{itemize}
In the active thread, Function $loop$ is called every $\Delta$ time
$t$. Firstly, the function increments the age of each neighbor in
$\mathcal{P}$. Then, the oldest peer $q$ is chosen to exchange a subset of its
partial view. If Peer $q$ cannot be reached (i.e. it crashed/left), the peer
$p$ executes the crash handling function (cf. Section~\ref{subsec:leaving}) and
repeats the process until it finds a reachable peer $q$. Peer $p$ selects a
sample of its partial view, excluding one occurrence of $q$ and including
itself. The size of this sample is half of its partial view, with at least one
peer: the initiating peer (cf. Line~\ref{line:samplesize}). The answer of $q$
contains half of its partial view too. Since peers can appear multiple times in
$\mathcal{P}$, the exchanging peers may send references to the other peer,
e.g., Peer $o$'s sample can contain references to $q$. Such sample, without
further processing, would create self-loop ($q$'s partial view contains
references to $q$). To alleviate this undesirable behavior, all occurrences of
the other peer are replaced with the emitting peer
(cf. Line~\ref{line:replace1},~\ref{line:replace2}).  Afterwards, both of
them remove the sent sample from their view and add the received
sample. Additionally, the initiating peer removes an occurrence of the chosen
peer $q$.

\begin{figure}
  \centering
  \input{input/cyclicexample.tex}
  \caption{\label{fig:cyclicexample}Example of the \SCAMPLON{}'s cyclic
    protocol. This scenario follows from Figure~\ref{fig:joiningexample}: Peer
    $p_1$ just joined the network. Peer $p_6$ initiates an exchange with $p_1$
    (the oldest among the $p_6$'s partial view). It randomly chooses
    $\left\lceil{|\mathcal{P}_6|\over{2}}\right\rceil-1 = 1$ peer among its
    neighborhood. In this case, it picks $p_9$ from $\{p_9,\,p_8,\,p_7\}$.  It
    sends the chosen peer plus its own identity to Peer $p_1$. In response, the
    latter picks $\left\lceil{|\mathcal{P}_1|\over{2}}\right\rceil = 1$ peer
    from its partial view. It sends back its sole neighbor $p_2$ and directly
    adds the received neighbor to its partial view. After receipt, Peer $p_6$
    removes the sent neighbors from its partial view, removes an occurrence of
    $p_1$, and adds the received peer from $p_1$. The peers $\{p_6,\,p_9\}$
    compose the $p_1$'s partial view. The peers $\{p_2,\,p_7,\,p_8\}$ compose
    the $p_6$'s partial view.}
\end{figure}

Figure~\ref{fig:cyclicexample} depicts the \SCAMPLON{}'s cyclic procedure. The
example shows that, at first, the initiating peer has $4$ peers in its partial
view, while the receiving peer has only $1$ peer. Then, after the exchange, the
former has $3$ neighbors including $1$ new peer. The receiving peer has $2$
neighbors, and both of them are new. Thus, the periodic procedure tends to
even up the partial view size of network members. It also scatters neighbors in
order to remove the highly clustered groups which may appear because of the
joining protocol.

\subsection{Leaving}
\label{subsec:leaving}

Using \SCAMPLON{}, the peers are free to leave the network without giving
notice. In that regard, we do not consider the departures and the crashs
differently.  Without any appropriate reaction, the network may collapse due to
an over zealous removal of connections. Indeed, when a peer joins the network,
it injects in it $1+\ln(|\mathcal{N}|)$ connections. Nevertheless, after few
exchanges, the partial view of the joining peer becomes populated with more
neighbors. Then, if this peer leaves, it removes $\ln(|\mathcal{N}|)$
connections from its partial view, and another $\ln(|\mathcal{N}|)$ connections
from peers which have this peer in their partial view. Therefore, without any
crash handler, we remove $2\ln(|\mathcal{N}|)$ connections instead of
$1+\ln(|\mathcal{N}|)$. To alleviate this issue, each peer that detects a crash
may reestablish a connection with anyone in its neighborhood (which will spread
in the network over the exchanges). The probability of reestablishing a
connection is $1-{1\over{|\mathcal{P}|}}$. Since
${|\mathcal{P}|}\approx \ln(|\mathcal{N}|)$ peers have the crashed peer in
their partial view, it is likely that all of them will reestablish a
connection, excepted one. Therefore, when a peer leaves, it approximately
removes the number of connections it injected when it joined.

\begin{algorithm}
  \input{./input/unreachablealgo.tex}
  \caption{\label{algo:unreachable}The crash/leaving handler of \SCAMPLON{}.}
\end{algorithm}

Algorithm~\ref{algo:unreachable} shows the manner in which \SCAMPLON{} deals
with crashes. When the peer $q$ is detected as crashed, a first loop counts the
occurrences of this neighbor in the partial view, and removes all of them. The,
the second loop probabilistically doubles a connection with a known peer. The
probability depends of the partial view size before the removals.

\begin{figure}
  \input{./input/crashexample.tex}
  \caption{\label{fig:crashexample}Example of \SCAMPLON{}'s crash/leaving
    handler. The scenario follows from prior examples after few other
    exchanges. Peer $p_1$ leaves the network without giving notice. With it,
    $7$ connections are down. Peers $p_3$, $p_4$, and $p_5$ have the
    crashed/left peer in their partial view. Peer $p_5$ has
    $1-{1\over{|\mathcal{P}_5|}}={2\over{3}}$ chance to replace the dead
    connections. In this case, it doubles the connection to
    $p_{13}$. Identically, $p_3$ and $p_4$ detect the crash/leaving and run the
    appropriate procedure. Only $p_3$ doubles one of its connection. In total,
    $5$ connections have been removed.}
\end{figure}

Figure~\ref{fig:crashexample} depicts the \SCAMPLON{}'s crash/leaving
handler. The example shows that some peers reestablish connections if they
detect a dead connection. The probability depends on the partial view size of
each of these peer. In average, one of these peer will likely remove the
connection while the other peers will double one of their existing
connections. In this case, Peer $p_1$ injected $5$ connections when it
joined. It removes $7-2 =5 $ connections when it leaves. The global number of
connections remains logarithmic compared to the number of members in the
network. Nevertheless, we can see that connectedness is not entirely guaranteed
(only with the high probability implied by random graphs). Indeed, if Peer
$p_1$ is the sole bridge between two clusters, adding connections is not enough
to ensure connectedness (more details in Section~\ref{subsec:churn}).

Note that extending the algorithms to handle three-way handshake is not
difficult: it only requires to keep track of the neighbor from where the
membership messages arrived, and forward the answer to this neighbor
accordingly. Also, there are few optimization concerning the establishments of
connections. For instance, when a peer $p$ starts an exchange with $q$, and $q$
has $p$ in its partial view, instead of inverting the link between $p$ and $q$,
and $q$ and $p$, \SCAMPLON{} does not change them. Another optimization
concerns a peer having a neighbor multiple times in its partial view. While
\SCAMPLON{} keeps such information in its partial view, only one connection per
neighbor is truly necessary.

To summarize, \SCAMPLON{} provides:
\begin{inparaenum}[(i)]
\item a logarithmically increasing partial view size compared to the global
  network size,
\item a constant complexity to establish the connections,
\item an exponentially fast convergence to a random graph.
\end{inparaenum}
Providing these three properties, \SCAMPLON{} improves the state-of-the-art
approaches~\cite{ganesh2001scamp,voulgaris2005cyclon} in the traditional
connection set-up. Furthermore, the improvement becomes crucial in the context
of three-way handshake connection set-up.  The latter becomes increasingly
important with the appearance of technologies allowing peer-to-peer within
modern web browsers.  The next section aims to demonstrate experimentally the
behavior of \SCAMPLON{}. In particular, it aims to highlight the aforementioned
properties.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
