
\section{Scamplon}
\label{sec:proposal}

Scamplon\footnote{Scamplon stands as the contraction of Scamp and Cyclon.} is a
random peer sampling protocol inspired by both Scamp and Cyclon. It provides
the best of its parents: a logarithmically increasing partial view size
compared to the global network size, and fast convergence to a random graph
using only neighbour-to-neighbour connection establishments. As such, it
constitutes an improvement over state-of-the-art approaches in the common
context of one-way connections. Additionally, it greatly outperforms
state-of-the-art in the three-way handshake connection establishments. The
latter context becomes increasingly important with the apparition of technology
allowing peer-to-peer within modern web browsers. This section details the
Scamplon protocol through intuitions, examples and algorithms.

\begin{asparadesc}
\item [Scamplon] reuses the joining process of Scamp to incrementally build the
network. While such network is not flawless, it has the interesting property of
logarithmically increasing the number of connections at each join, compared to
the global network size. Still, newest members have a small partial view size,
and oldest peers are more clustered. To alleviates these issues, a periodic
Cyclon-like protocol takes place in order to balance the partial views, using
only neighbour-to-neighbour interactions. This balancing concerns both the
partial view sizes, and the uniformity of chosen peers within
them. Unfortunately, Cyclon handles fixed-size partial views. Therefore, it
must be adapted to handle partial views that grow and shrink as the network
dynamically adapts to the membership.
\end{asparadesc}

The first issue of Cyclon concerns the partial view sizes. For the recall, the
user of Cyclon must foresee the maximum size of the network to set the partial
view size, and the size of the subset to exchange from neighbour-to-neighbour.
However, in Scamplon, a peer with $2$ neighbours in its partial view can
exchange with a peer with $10$ neighbours. Ideally, the resulting size of both
partial views would be $6$ after the exchange. Yet, reaching this ideal value
in one cycle is difficult without the knowledge of each other's partial view
size. Instead of acquiring this knowledge, Scamplon aims to converge to the
ideal value by averaging their view size over exchanges. Therefore, the
initiating peer sends $\left\lceil\mathcal{P}\over{2}\right\rceil$ members to
the chosen peer (chosen by age). The latter sends back
$\left\lceil\mathcal{P}\over{2}\right\rceil$ members too. After the receipt,
both peers remove the sent members and add the received members. It worth
noting that the global number of connections after the process must not
change. Otherwise, Scamplon cannot guarantee that the partial view sizes are
logarithmic in average compared to the network size.

A remarkable difference regarding Cyclon is that Scamplon explicitly allows to
have a same neighbour multiple times in a partial view. It impacts on the
clustering coefficient. However, the impact is not significant since these
artefacts are not numerous because the graph is random, and because they
disappear over the Scamplon cycles (EXAMPLIFY).

There are few optimisations concerning the establishments of connections. For
instance, when a peer $p$ starts an exchange with $q$, and $q$ has $p$ in its
partial view, instead of inverting the link between $p$ and $q$, and $q$ and
$p$, Scamplon does not change them. Another optimisation concerns a peer having
a neighbour multiple times in its partial view. While Scamplon keeps such
information in its partial view, only one connection per neighbour is
necessary.

\begin{asparadesc}
\item [Algorithm]\ref{algo:scamplon} shows the Scamplon protocol running at
  each peer. It is divided between an active thread looping to update the
  partial view, and the passive thread which provides the reactions to received
  messages. A peer $o$ joining the network will reach a contact peer. The
  latter will call Function $onContact$ which spreads $(|\mathcal{P}|+c)$
  copies of $o$ inside the network. Then, each time a peer receives one of
  these message, assuming that this peer does not have $o$ already and this
  peer is not $o$, it has a probability $1\over{|\mathcal{P}|+1}$ to integrate
  $o$ in $\mathcal{P}$. Otherwise it forwards the copy to a random neighbour.
  At this point, $o$ has $1$ neighbour in its partial view, and appears
  $(c+(c+1)log(N))$ times in partial views of other members. The active thread
  aims to balance the partial views. Each time Function $loop$ is called, the
  age of each element in $\mathcal{P}$ is incremented. Then, the oldest peer
  $q$ is chosen to exchange a subset of their partial view. If Peer $q$ cannot
  be reached (i.e. it crashed/disconnected), it is removed from the partial
  view and the operation is repeated. Once the initiating peer $p$ found a
  reachable peer $q$, the former selects a sample of its partial view,
  excluding $q$ and including itself. The size of this sample is half of its
  partial view, with a minimum of one peer: the initiating peer. The answer of
  $q$ is of the exact same kind. Afterwards, both of them remove the sent
  sample from their view, remove the chosen neighbour, and add the received
  sample.
\end{asparadesc}

Note that extending the algorithm to provide handshaking is not difficult: it
only requires to keep track of the neighbour from where the membership messages
arrived, and forward the answer to this neighbour accordingly.

\begin{algorithm}
  \input{./input/scamplonalgo.tex}
  \caption{\label{algo:scamplon}The Scamplon protocol.}
\end{algorithm}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
