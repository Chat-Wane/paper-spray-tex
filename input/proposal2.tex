
\section{Use case: real-time editing}
\label{sec:use-case}
%%\subsection{Decentralized collaborative editor}
%%\label{subsec:editor}

Google Docs made real-time editing in browsers easy for millions of
users. However, Google mediates real-time editing sessions with central servers
raising issues on privacy, censorship, economic intelligence. It also raises
scalability issues in term of number of participants.  Despite that small groups
currently constitute the main range of users, events such as massive online
lectures, TV shows, conferences gather larger groups.  Google Docs supports
large groups but only the first fifty users can edit, next users have their
rights limited to document reading. In addition, real-time editing sessions can
be highly dynamic; even if only few authors are editing a document
simultaneously, the editing session includes a much larger group of potential
writers. We think that real-time editors should allow editing at anytime and
anywhere, whatever the number of participants, without third party.

Decentralized real-time editors~\cite{oster2006data, sun1998operational,
  sun2009contextbased} do not require intermediate servers and by the same solve
privacy issues. However, scalability issues remain.  Addressing scalability
requires finding a good trade-off between communication, space and time
complexities. Among others, achieving a sublinear communication complexity is
crucial for supporting large groups.  It depends on both diffusion of messages,
and the content of messages.

In this paper, we introduce \CRATE as a distributed and decentralized
CollaboRATive Editor. It aims to highlight the benefits brought by \SPRAY on
messages diffusion. Thanks to \SPRAY, \CRATE builds a network of browsers where
each browsers is able to communicate with a logarithmically scaling number of
browsers compared to the global network size. Each change performed on documents
transits neighborhoods to reach all members in a scalable
way~\cite{birman1999bimodal}. Contrarily to
state-of-the-art~\cite{tolgyeski2009adaptive, voulgaris2005cyclon}, \SPRAY
allows the diffusion cost to adapt to the network size. Thus, small networks do
not pay the price of large networks.

As for the content of messages, \CRATE uses a sequence data structure
% Conflict-free Replicated Data
%Type~\cite{shapiro2011conflict, shapiro2011comprehensive} (CRDT) for sequences
that guarantees eventually consistent documents, i.e., documents converge to an
identical state~\cite{bailis2013eventual}. It allocates an identifier to each
element of the sequence representing the document. Using the allocation function
\LSEQ~\cite{nedelec2013lseq}, \CRATE is able to keep the space of these
identifiers under a polylogarithmic bound compared to the document size.

As consequence, the communication complexity of \CRATE is upper-bounded by
$\mathcal{O}((\log d)^2\ln(|\mathcal{N}|))$ where $d$ is the document size and
$|\mathcal{N}|$ is the editing session size.

\subsection{Architecture}

\begin{figure}
  \centering
  \input{input/architecture.tex}
  \caption{\label{fig:architecture}\CRATE's architecture comprises 4
    layers.}
\end{figure}

Figure~\ref{fig:architecture} depicts \CRATE's architecture which comprises four
layers:
\begin{inparaenum}[(i)]
\item communication: includes the editing session membership mechanism and the
  information dissemination protocols.
\item causality: includes the causality tracking
  structure~\cite{malkhi2007concise} that guarantees that the delivery of the
  removal of an element never precedes its insertion.
\item sequence structure: includes the structure that guarantees a global
  total order among elements of the sequence.
\item graphical user interface: includes the editor as a graphical entity that
  users can interact with inside web browsers.
\end{inparaenum}
Figure~\ref{fig:architecture} also depicts the process chain of \CRATE: when
users perform an operation on the document, the operation is applied to the
shared sequence which creates an \LSEQ identifier. Then it decorates the result
of the operation with causality tracking metadata. Finally, \CRATE broadcasts it
using the neighborhood provided by \SPRAY.  Conversely, when \CRATE receives a
broadcast message, it checks if the operation is causally ready to be
delivered. Once the condition is verified, it applies the operation to the
shared sequence which notifies the graphical user interface of the changes.

%% The rest of this section details the main components of \CRATE and their
%% respective contributions to complexities.


\subsection{Epidemic dissemination}
\label{subsec:gossiping}

Epidemic dissemination~\cite{birman1999bimodal,demers1987epidemic} (or
gossiping) relies on the membership protocol to propagate messages in a scalable
way to all members (broadcast). Algorithm~\ref{algo:gossiping} shows the simple
functioning of this protocol. When a peer emits a message, it sends it to its
neighborhood. Each peer receiving such messages forwards it to its neighborhood
too. Messages transitively reach all peers of the network.

\begin{algorithm}[h]
  \input{./input/gossipingalgo.tex}
  \caption{\label{algo:gossiping}Epidemic dissemination protocol.}
\end{algorithm}

Since the gossiping algorithm depends of the neighborhood provided by \SPRAY,
and since the latter grows logarithmically compared to the network size, the
communication complexity of an application is upper-bounded by
$\mathcal{O}(m \ln |\mathcal{N}|)$, where $m$ is the space complexity of a
message. To scale, applications are in charge of keeping $m$ under a sublinear
upper bound.

% \subsection{Causality tracking}

% The role of causality tracking is twofold:
% \begin{inparaenum}
% \item guarantee the one time delivery and forwarding of broadcast messages
%   (cf. Line~\ref{line:alreadyreceived} of Algorithm~\ref{algo:gossiping}),
% \item guarantee that the removal of an element never precedes its insertion.
% \end{inparaenum}
% \CRATE uses a version vector with exceptions~\cite{malkhi2007concise}


\subsection{A scalable sequence data structure}

Real-time distributed collaborative editors consider multiple participants, each
hosting a copy of a shared sequence of characters. A participant updates at any
time its local copy by inserting or deleting a character. Then, the operation is
eventually delivered to all other members. Finally, delivered operations are
re-executed~\cite{saito2005optimistic}. Consistency requires that all members
eventually converge to an identical state, i.e., when the system is idle, all
copies become similar.

\CRATE uses a sequence data structure that belongs to the class of Conflict-free
Replicated Data Types (CRDTs)~\cite{shapiro2011conflict,
  shapiro2011comprehensive}. It provides two commutative operations to update
documents: \emph{insert} and \emph{delete}.  They use totally ordered, unique,
and immutable identifiers associated to each character to guarantee consistent
copies of the document. Nevertheless, they require storing these identifiers. In
this paper, we focus on variable-size identifiers~\cite{preguica2009commutative,
  weiss2009logoot}. Thus, identifiers are lists determined at generation.

To generate its identifiers, \CRATE uses \LSEQ~\cite{nedelec2013lseq}, an
allocation function that provides identifiers enjoying a polylogarithmic upper
bound $\mathcal{O}((\log d)^2)$ on space complexity compared to the document
size $d$. \TODO{Indeed, identifiers can be factorized into a tree structure where they
represent a path to their character. \LSEQ uses an exponential tree, i.e., a
tree where each element has twice as much children as its parent. Considering a
path [$l_1.l_2\ldots l_k$], $k$ being the depth of the element in the tree,
$l_k$ requires 1 additionnal bit to encode than $l_{k-1}$. As consequence,
identifiers reflect the document size.}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
