
\begin{figure*}
\centering
\subfloat[Figure A][\label{fig:webrtcA}
$p_1$ connects to $p_2$ using the signaling service. 
1: $p_1$ pushes its offer ticket; 
2: $p_2$ pulls the ticket; 
3: $p_2$ pushes its response; 
4: $p_1$: pulls the response and establishes a 
connection with $p_2$. $p_3$ does the same with $p_2$. 
%%Figure~\ref{fig:webrtcB} depicts the resulting network.
]{
  \input{input/signalingexampleA.tex}}
\hspace{5pt}
\subfloat[Figure B][\label{fig:webrtcB}
$p_1$ connects to $p_3$ using $p_2$ as mediator. 
1: $p_1$ sends its offer ticket to $p_2$; 
2: $p_2$ forwards it to $p_3$ and registers $p_1$ as the emitter; 
3: $p_3$ sends its response to $p_2$; 
4: $p_2$ forwards it to the emitter $p_1$ which connects to $p_3$.]{
  \input{input/signalingexampleB.tex}}
\hspace{5pt}
\subfloat[Figure C][\label{fig:webrtcC}
The resulting network overlay: a fully connected network composed of
3 members.]{
  \input{input/signalingexampleC.tex}}
\caption{\label{fig:webrtc}Creating an overlay network on top of WebRTC.}
\end{figure*}


\section{Related work}
\label{sec:relatedwork}


WebRTC allows real-time peer-to-peer communication between browsers even when
complex network settings such as firewalls, proxies or Net Address Translation
(NAT) are involved. However, WebRTC does not manage addressing nor routing. To
establish a connection, the browsers exchange offers and acknowledgments
through a common mediator, e.g., mails, dedicated signaling services
\footnote{\url{http://peerjs.com/}}, existing WebRTC
connections\footnote{\url{http://ozan.io/p/}} etc. In
Figure~\ref{fig:webrtcA}, $p_1$ wants to connect to $p_2$. Therefore, $p_1$
pushes an offer ticket to a shared signaling service\footnote{Many signaling
  services can exist}. Peer $p_2$ pulls the offer, stamps it and pushes it back
to the signaling service. Finally, $p_1$ pulls the stamped ticket and
establishes a bidirectional connection with $p_2$.  Identically, $p_3$
establishes a connection to $p_2$. We refer to the round-trip procedure as
\emph{three-way handshake}. At this point, Peer $p_1$ is able to establish a
connection to $p_3$ without the mediation of the former signaling service.
Instead, it uses $p_2$ as temporary signaling service.  As shown in
Figure~\ref{fig:webrtcB}, Peer $p_1$ pushes an offer ticket to $p_2$. As
$p_2$ is already connected to $p_3$, it forwards the offer to $p_3$ and
registers $p_1$ as the emitter. Peer $p_3$ stamps the ticket and sends it back
to $p_2$ who then forwards it back to $p_1$. Upon receipt, $p_1$ establishes a
bidirectional connection with $p_3$.  Notice that if $p_2$ crashes during the
forwarding process, the connection establishment will fail, even if an
alternative route exists as WebRTC does not manage routing.

Using signaling services and existing WebRTC connections allows easy
deployment of random peer sampling protocols~\cite{jelasity2004peer} in
browsers that can run on mobile phones or tablets connected to mobile
networks. In this context, it is crucial to keep the number of connections as
low as possible in order to reduce traffic usage and limit resource
consumption.

Random peer sampling protocols~\cite{jelasity2004peer, jelasity2007gossip} 
provide each
peer with a partial view $\mathcal{P}$ of the network membership
$\mathcal{N}$. They populate the partial views with references to
peers chosen at random among $\mathcal{N}$ following a uniform
distribution using local knowledge only. Their goal is to converge to
an overlay network exposing properties similar to those of random
graphs~\cite{erdos1959random}. They efficiently provide connectedness,
robustness, information dissemination etc. A wide variety of gossip-based
protocols use random peer sampling (e.g. topology
management~\cite{voulgaris2005epidemic, jelasity2009tman,
  dabek2004vivaldi}).

The representatives of random peer sampling protocols using a fixed-size
partial view~\cite{jelasity2007gossip} are
lpbcast~\cite{eugster2003lightweight}, Newscast~\cite{tolgyeski2009adaptive},
and \CYCLON~\cite{voulgaris2005cyclon}. They have to know \emph{a priori} the
maximum network size to set their parameters
accordingly. These decisions cannot be safely retracted afterwards.

This inflexibility makes it possible to maintains 7 connections in the browser
despite requiring only 4, while, in the following moment, it still maintains 7
connections while 10 would be needed.
\CYCLON's partial views are commonly oversized compared to the actual network
size to prevent having too few connections per peer,
which, consequently, introduces overhead.
When WebRTC is involved, we need a dynamic peer sampling
service that is able to adapt to the dynamic number of participants.

Network size estimators can introduce adaptiveness in peer sampling. These
approaches either use
\begin{inparaenum}[(i)]
\item sampling techniques~\cite{mane05network, ganesh2007peer,
    kostoulas2007active} which analyze a network subset and deduce the network
  size using probabilistic functions,
\item sketching techniques~\cite{flajolet2008hyperloglog, baquero2012extrema}
  which use hashing to compress the high amount of data and deduce the network
  size using the collisions,
\item averaging techniques~\cite{jelasity2004epidemic, blasa2011symmetric}
  which use aggregations that converge over exchanges to a value which depends
  on the network size.
\end{inparaenum}
Unfortunately, while they can be very precise in their estimation, they imply a
communication overhead and may have strong assumptions (e.g. random graph
topology). However, adaptiveness should introduce a minimum overhead
to peer sampling in WebRTC applications.

%% figure related to proposal, here to be on top of page
\begin{figure*}
  \centering
  \subfloat[Figure A][$p_1$ contacts $p_2$ to join the network. $p_1$ adds
  $p_2$ to its neighborhood. $p_1$ sends its request to $p_2$.]{
    \input{./input/joiningexampleA.tex}}
  \hspace{8pt}
  \subfloat[Figure B][The $onSubs(p_1)$ event is raised at $p_1$
  which forwards the subscription to $p_1$'s neighborhood.]{
    \input{./input/joiningexampleB.tex}}
  \hspace{8pt}
  \subfloat[Figure C][The $onFwdSubs(p_1)$ event is raised at $p_{3-6}$. The 
  peers add $p_1$ to their neighborhood.]{
    \input{./input/joiningexampleC.tex}}
  \caption{\label{fig:joiningexample}Example of the \SPRAY's joining
    protocol.}
\end{figure*}

The sole representative of adaptive-by-design random peer sampling is
\SCAMP~\cite{ganesh2001scamp,ganesh2003peer}. Its interesting property lies in
its logarithmically growing partial view sizes meeting the sharp threshold of
connectedness of random graphs~\cite{erdos1959random}. Nevertheless, \SCAMP
suffers from other drawbacks. In particular, it systematically disseminates the
connections at random. Thus, the originating peer can be several hops away
from the arrival peer. In WebRTC, each random dissemination path must be
traveled back to finalize the connection establishment, as illustrated in
Figure~\ref{fig:webrtc}. This drastically impacts the \SCAMP failure
probability of establishing a connection.  Let $P_f$ be the probability that an
element of the dissemination path (either a peer or a connection) crashes or
leaves during a hop of the three-way handshake, without any possible
recovery. Let $P_E$ be the probability that a connection establishment cannot
be completed. Without three-way handshake, $P_E$ is straightforward:
\begin{equation} P_{E,\,1way}^{Scamp}=1-(1- P_f)^{k+1} \end{equation} This
corresponds to the probability that each element (arc and peer) in the path of
size $k+1$ stays alive during their part of the dissemination (i.e., otherwise,
they are allowed to crash or leave). In the context of WebRTC, the offer ticket must
travel back to its emitter. As a consequence, the elements of the random
dissemination path are not allowed to fail until the stamped ticket travels
back. We obtain:
\begin{align} P_{E,\,3way}^{Scamp} &=1 - ((1-P_f)^{2(k+1)} (1-P_f)^{2k}
                                     \ldots (1-P_f)^2) \nonumber \\
                                   &=1-(1-P_f)^{k^2+3k+2}
\end{align}
In other terms, the first chosen arc and peer in the path must stay alive
$2k+2$ hops, the second chosen arc and peer must stay alive $2k$ hops etc.  The
complexity class of the \SCAMP failure rate increases leading to a quicker
degeneration of the connection count. This behavior endangers the network
connectedness.%%, as depicted in Section~\ref{subsec:degeneration}.

Building an adaptive-by-design random peer sampling that meets WebRTC
constraints raises the following scientific problem:
\begin{problem}
  Let $t$ be an arbitrary time frame, let $\mathcal{N}^t$ be the network
  membership at that given time $t$ and let $\mathcal{P}_x^t$ be the partial
  view of peer $p_x \in \mathcal{N}^t$.  A cost-efficient random peer sampling
  should provide the following best-case properties:
  \begin{enumerate}
  \item Partial view size: \hfill
    $\forall p_x \in \mathcal{N}^t,\, |\mathcal{P}_x^t| = \Theta (\ln
    |\mathcal{N}^t|)$      
  \item Connection establishment: \hfill $O(1)$
    %% \item  \begin{center}
    %%     Convergence speed: \hfill $\Theta(\exp \, t^{-1})$
    %%   \end{center}
  \end{enumerate}
\end{problem}

The first condition states that the partial view size is relative to the size
of the network at any time. It also states that partial views grow and shrink
logarithmically compared to the size of the network. The second condition
states that each connection establishment requires a constant number of
intermediary peers. Since this number is constant, connection establishments
do not depend on the network size.
%% The last condition states that the network
%% overlay converges exponentially fast to a topology that is close to a random
%% graph.
Lpbcast, Newscast and \CYCLON fail to meet the first condition of the problem
statement since they do not adapt their views to the network size. \SCAMP fails
to meet the second condition of the problem statement since each connection
implies an unsafe random dissemination protocol.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
